/**
 * Agent Factory Agent - Self-Bootstrapping Agent Generation System
 * 
 * This agent creates other specialized agents that follow Equilateral AI patterns,
 * including Lambda handlers, TypeScript components, API endpoints, and tests.
 * 
 * Copyright (c) 2025 Equilateral AI (Pareidolia LLC)
 * Integrated from multi-project innovations into core system.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class AgentFactoryAgent {
  constructor() {
    this.projectRoot = process.cwd();
    this.templatesDir = path.join(this.projectRoot, 'src/agents/templates');
    this.outputDir = path.join(this.projectRoot, 'src/agents/generated');
    
    // Ensure directories exist
    this.ensureDirectoryStructure();

    // Load Equilateral standards from EquilateralAgents-Open-Standards
    this.standards = this.loadTimComboStandards();
  }

  /**
   * Ensure required directory structure exists
   */
  ensureDirectoryStructure() {
    const dirs = [
      this.templatesDir,
      this.outputDir,
      path.join(this.outputDir, 'handlers'),
      path.join(this.outputDir, 'components'),
      path.join(this.outputDir, 'hooks'),
      path.join(this.outputDir, 'types'),
      path.join(this.outputDir, 'tests')
    ];

    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`üìÅ Created directory: ${dir}`);
      }
    });
  }

  /**
   * Load Equilateral standards from EquilateralAgents-Open-Standards
   */
  loadTimComboStandards() {
    const standardsFiles = [
      'api_design_standards.md',
      'development_principles.md',
      'testing_principles.md',
      'cost_optimization_principles.md'
    ];

    const standards = {};

    standardsFiles.forEach(file => {
      const filePath = path.join(this.projectRoot, 'EquilateralAgents-Open-Standards', file);
      if (fs.existsSync(filePath)) {
        standards[file.replace('.md', '')] = fs.readFileSync(filePath, 'utf8');
      }
    });

    return standards;
  }

  /**
   * Generate a specialized Lambda handler following method-specific patterns
   */
  generateLambdaHandler(config) {
    const {
      handlerName,
      httpMethod,
      endpoint,
      description,
      businessLogic,
      queryParams = [],
      bodyParams = [],
      responseType
    } = config;

    // Use method-specific parameter patterns from backend_handler_standards.md
    const parameterPattern = ['GET', 'DELETE'].includes(httpMethod) 
      ? 'queryStringParameters: queryParams = {}'
      : 'body: requestBody = {}';

    const parameterAccess = ['GET', 'DELETE'].includes(httpMethod)
      ? queryParams.map(param => `    const ${param} = queryParams.${param};`).join('\n')
      : bodyParams.map(param => `    const ${param} = requestBody.${param};`).join('\n');

    const handlerCode = `/**
 * ${description}
 * HTTP Method: ${httpMethod} ${endpoint}
 * Generated by Agent Factory following method-specific handler patterns
 */

const { wrapHandler } = require('./lambdaWrapper');
const { executeQuery } = require('./dbOperations');
const { createSuccessResponse, createErrorResponse } = require('./responseUtil');
const { handleError } = require('./errorHandler');

/**
 * ${handlerName} - ${description}
 */
async function ${handlerName}({ ${parameterPattern}, requestContext }) {
    try {
        const Request_ID = requestContext.requestId;
        
        // Extract parameters following method-specific patterns
${parameterAccess}
        
        // Business logic
        ${businessLogic}
        
        // Execute database query
        const query = \`
            -- Generated query for ${handlerName}
            SELECT * FROM table_name WHERE condition = $1
        \`;
        
        const result = await executeQuery(query, [/* parameters */]);
        
        return createSuccessResponse(
            { Records: result.rows },
            '${description} completed successfully',
            {
                Total_Records: result.rows.length,
                Request_ID,
                Timestamp: new Date().toISOString()
            }
        );
        
    } catch (error) {
        console.error('${handlerName} Error:', error);
        return handleError(error);
    }
}

exports.handler = wrapHandler(${handlerName});
`;

    const outputPath = path.join(this.outputDir, 'handlers', `${handlerName}.js`);
    fs.writeFileSync(outputPath, handlerCode);
    
    console.log(`üîß Generated Lambda handler: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate complete feature following all Equilateral patterns
   */
  generateCompleteFeature(config) {
    const {
      featureName,
      description,
      domain,
      database,
      api,
      frontend,
      tests
    } = config;

    console.log(`üöÄ Generating complete feature: ${featureName}`);
    console.log(`üìã Description: ${description}`);

    const generatedFiles = [];

    // Generate database types
    if (database) {
      generatedFiles.push(this.generateTypesFromSchema({
        tableName: database.tableName,
        description: database.description,
        fields: database.fields,
        relationships: database.relationships
      }));
    }

    // Generate API endpoints
    if (api) {
      generatedFiles.push(this.generateAPIEndpoints({
        domain: domain,
        endpoints: api.endpoints,
        description: api.description
      }));
    }

    // Generate Lambda handlers
    if (api && api.handlers) {
      api.handlers.forEach(handler => {
        generatedFiles.push(this.generateLambdaHandler(handler));
      });
    }

    console.log(`‚úÖ Feature '${featureName}' generated successfully!`);
    console.log(`üìÅ Generated ${generatedFiles.length} files`);
    
    return {
      featureName,
      generatedFiles,
      summary: `Generated complete ${featureName} feature with ${generatedFiles.length} files following Equilateral standards`
    };
  }

  /**
   * Create domain-specific agent extension
   */
  createDomainExtension(domain, extensionConfig) {
    const { baseAgent, domainCapabilities, patterns } = extensionConfig;
    
    const extensionCode = `/**
 * ${domain} Domain Extension for ${baseAgent}
 * Generated by Agent Factory
 */

const ${baseAgent} = require('../${baseAgent}');

class ${domain}${baseAgent} extends ${baseAgent} {
    constructor(config) {
        super(config);
        this.domain = '${domain}';
        this.domainCapabilities = ${JSON.stringify(domainCapabilities, null, 8)};
        this.domainPatterns = ${JSON.stringify(patterns, null, 8)};
    }

    // Domain-specific method extensions
    ${domainCapabilities.map(capability => `
    async ${capability}(context) {
        // Apply domain-specific patterns
        const domainContext = {
            ...context,
            domain: this.domain,
            patterns: this.domainPatterns
        };
        
        // Call base capability with domain enhancements
        const baseResult = await super.performAnalysis?.(domainContext) || {};
        
        // Add domain-specific analysis
        const domainResult = await this.performDomainAnalysis(domainContext);
        
        return this.mergeDomainResults(baseResult, domainResult);
    }`).join('')}

    async performDomainAnalysis(context) {
        // Domain-specific analysis logic
        return {
            domain: this.domain,
            analysis: 'Domain-specific analysis completed',
            patterns_applied: this.domainPatterns,
            timestamp: new Date().toISOString()
        };
    }

    mergeDomainResults(baseResult, domainResult) {
        return {
            ...baseResult,
            domain_analysis: domainResult,
            enhanced: true
        };
    }
}

module.exports = ${domain}${baseAgent};
`;

    const outputPath = path.join(this.outputDir, `${domain}${baseAgent}.js`);
    fs.writeFileSync(outputPath, extensionCode);
    
    console.log(`üéØ Generated domain extension: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate React TypeScript Component with Flowbite integration
   */
  generateReactComponent(config) {
    const {
      componentName,
      description,
      props = [],
      hooks = [],
      apiIntegration = null,
      storybook = true
    } = config;

    const propsInterface = props.length > 0 
      ? `interface ${componentName}Props {\n${props.map(prop => `  ${prop.name}: ${prop.type};${prop.optional ? ' // Optional' : ''}`).join('\n')}\n}`
      : `interface ${componentName}Props {}`;

    const componentCode = `/**
 * ${componentName} - ${description}
 * Generated by Agent Factory following frontend standards
 */

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Alert, Button, Card, Modal, Spinner } from 'flowbite-react';
import { ${hooks.map(h => h.icon).filter(Boolean).join(', ')} } from 'react-icons/hi';
${apiIntegration ? `import { Make_Authorized_API_Call, API_ENDPOINTS } from '../../../api/${apiIntegration.domain}';` : ''}

${propsInterface}

const ${componentName}: React.FC<${componentName}Props> = React.memo(({
${props.map(prop => `  ${prop.name}${prop.optional ? '?' : ''}`).join(',\n')}
}) => {
  // Component state
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  ${hooks.map(hook => `const [${hook.state}, set${hook.state.charAt(0).toUpperCase() + hook.state.slice(1)}] = useState<${hook.type}>(${hook.defaultValue});`).join('\n  ')}

  // API integration
  ${apiIntegration ? `
  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Make_Authorized_API_Call<${apiIntegration.responseType}>(
        API_ENDPOINTS.${apiIntegration.domain.toUpperCase()}.${apiIntegration.endpoint.toUpperCase()},
        '${apiIntegration.method}',
        undefined,
        ${apiIntegration.method === 'GET' ? '{ params: { /* query params */ } }' : '{ /* request body */ }'}
      );
      
      if (result.success) {
        // Handle successful response
        const data = result.data.Records;
        // Update component state with data
      } else {
        setError(result.message || 'Failed to fetch data');
      }
    } catch (err) {
      setError('Network error occurred');
      console.error('${componentName} API Error:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);` : ''}

  // Memoized computations
  const computedValue = useMemo(() => {
    // Expensive calculations here
    return ${props.length > 0 ? props[0].name : 'null'};
  }, [${props.map(p => p.name).join(', ')}]);

  // Event handlers
  const handleAction = useCallback(() => {
    // Handle user actions
    console.log('Action triggered in ${componentName}');
  }, []);

  if (loading) {
    return (
      <div className="flex justify-center items-center p-8">
        <Spinner aria-label="Loading..." size="lg" />
        <span className="ml-2">Loading...</span>
      </div>
    );
  }

  if (error) {
    return (
      <Alert color="failure" onDismiss={() => setError(null)}>
        <span className="font-medium">Error:</span> {error}
      </Alert>
    );
  }

  return (
    <Card className="max-w-full">
      <div className="flex items-center justify-between">
        <h5 className="text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
          ${componentName}
        </h5>
        <Button onClick={handleAction} size="sm">
          Action
        </Button>
      </div>
      
      <p className="font-normal text-gray-700 dark:text-gray-400">
        ${description}
      </p>
      
      {/* Component content */}
      <div className="space-y-4">
        {/* Add your component-specific content here */}
        <p>Component rendered successfully</p>
      </div>
    </Card>
  );
});

${componentName}.displayName = '${componentName}';

export default ${componentName};`;

    const outputPath = path.join(this.outputDir, 'components', `${componentName}.tsx`);
    fs.writeFileSync(outputPath, componentCode);

    // Generate Storybook story if requested
    if (storybook) {
      this.generateStorybookStory(componentName, description, props);
    }

    console.log(`‚öõÔ∏è Generated React component: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate Storybook story for component
   */
  generateStorybookStory(componentName, description, props) {
    const storyCode = `/**
 * ${componentName} Stories
 * Generated by Agent Factory
 */

import type { Meta, StoryObj } from '@storybook/react';
import ${componentName} from './${componentName}';

const meta: Meta<typeof ${componentName}> = {
  title: 'Components/${componentName}',
  component: ${componentName},
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: '${description}',
      },
    },
  },
  tags: ['autodocs'],
  argTypes: {
    ${props.map(prop => `
    ${prop.name}: {
      description: '${prop.description || prop.name}',
      control: '${prop.control || 'text'}',
    }`).join('')}
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    ${props.map(prop => `${prop.name}: ${prop.defaultValue || "''"}`).join(',\n    ')}
  },
};

export const Loading: Story = {
  args: {
    ...Default.args,
    // Add loading state props
  },
};

export const WithError: Story = {
  args: {
    ...Default.args,
    // Add error state props
  },
};`;

    const storyPath = path.join(this.outputDir, 'components', `${componentName}.stories.tsx`);
    fs.writeFileSync(storyPath, storyCode);
    
    console.log(`üìö Generated Storybook story: ${storyPath}`);
    return storyPath;
  }

  /**
   * Generate TypeScript types from database schema
   */
  generateTypesFromSchema(config) {
    const { tableName, description, fields, relationships = [] } = config;
    
    const typeName = this.toPascalCase(tableName);
    
    const typeCode = `/**
 * ${typeName} Types
 * Generated from database schema by Agent Factory
 * 
 * ${description}
 */

// Base interface for ${typeName}
export interface ${typeName} {
${fields.map(field => `  ${field.name}: ${this.mapDatabaseTypeToTS(field.type)};${field.nullable ? ' // Nullable' : ''}${field.description ? ' // ' + field.description : ''}`).join('\n')}
}

// API Response wrapper for ${typeName}
export interface ${typeName}Response {
  Records: ${typeName}[];
  Total_Records: number;
  Request_ID: string;
  Timestamp: string;
}

// Request interfaces
export interface Create${typeName}Request {
${fields.filter(f => !f.generated).map(field => `  ${field.name}${field.required ? '' : '?'}: ${this.mapDatabaseTypeToTS(field.type)};`).join('\n')}
}

export interface Update${typeName}Request extends Partial<Create${typeName}Request> {
  ${fields.find(f => f.primaryKey)?.name || 'id'}: ${this.mapDatabaseTypeToTS(fields.find(f => f.primaryKey)?.type || 'string')};
}

// Query parameters
export interface ${typeName}QueryParams {
  limit?: number;
  offset?: number;
  sortBy?: keyof ${typeName};
  sortDirection?: 'ASC' | 'DESC';
  ${fields.filter(f => f.searchable).map(field => `${field.name}?: ${this.mapDatabaseTypeToTS(field.type)};`).join('\n  ')}
}

${relationships.map(rel => `
// ${rel.type} relationship with ${rel.table}
export interface ${typeName}With${this.toPascalCase(rel.table)} extends ${typeName} {
  ${rel.fieldName}: ${this.toPascalCase(rel.table)}${rel.type === 'many' ? '[]' : ''};
}`).join('\n')}

// Utility types
export type ${typeName}Fields = keyof ${typeName};
export type Partial${typeName} = Partial<${typeName}>;`;

    const outputPath = path.join(this.outputDir, 'types', `${typeName}.ts`);
    fs.writeFileSync(outputPath, typeCode);
    
    console.log(`üè∑Ô∏è Generated TypeScript types: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate API endpoint definitions
   */
  generateAPIEndpoints(config) {
    const { domain, endpoints, description } = config;
    
    const endpointCode = `/**
 * ${domain} API Endpoints
 * Generated by Agent Factory following API standards
 * 
 * ${description}
 */

import { APIResponse, APIErrorResponse } from '../types/API';
${endpoints.map(e => `import { ${e.responseType} } from '../types/${e.responseType}';`).join('\n')}

// API endpoint definitions for ${domain}
export const ${domain.toUpperCase()}_ENDPOINTS = {
${endpoints.map(endpoint => `
  ${endpoint.name.toUpperCase()}: {
    path: '${endpoint.path}',
    method: '${endpoint.method}' as const,
    description: '${endpoint.description}',
    parameters: {
      ${endpoint.method === 'GET' ? 'query' : 'body'}: [
        ${(endpoint.parameters || []).map(p => `'${p.name}'${p.required ? '' : '?'}`).join(', ')}
      ],
      headers: ['Authorization'],
    },
    responseType: '${endpoint.responseType}' as const
  }`).join(',')}
};

// Type-safe API client methods
export class ${this.toPascalCase(domain)}APIClient {
${endpoints.map(endpoint => `
  /**
   * ${endpoint.description}
   */
  static async ${endpoint.name}(
    ${endpoint.method === 'GET' 
      ? `params?: { ${(endpoint.parameters || []).map(p => `${p.name}${p.required ? '' : '?'}: ${p.type}`).join('; ')} }`
      : `data: { ${(endpoint.parameters || []).map(p => `${p.name}${p.required ? '' : '?'}: ${p.type}`).join('; ')} }`
    }
  ): Promise<APIResponse<${endpoint.responseType}> | APIErrorResponse> {
    
    const endpoint = ${domain.toUpperCase()}_ENDPOINTS.${endpoint.name.toUpperCase()};
    
    try {
      const response = await fetch(endpoint.path, {
        method: endpoint.method,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': \`Bearer \${getAuthToken()}\` // Implement getAuthToken()
        },
        ${endpoint.method === 'GET' 
          ? `${(endpoint.parameters || []).length > 0 ? '// Add query parameters to URL' : ''}`
          : `body: JSON.stringify(data)`
        }
      });

      if (!response.ok) {
        throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
      }

      const result = await response.json();
      return result as APIResponse<${endpoint.responseType}>;
      
    } catch (error) {
      console.error('${endpoint.name} API Error:', error);
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error',
        error_code: 'API_ERROR',
        timestamp: new Date().toISOString()
      } as APIErrorResponse;
    }
  }`).join('\n')}
}

// Helper function to get auth token (implement based on your auth system)
function getAuthToken(): string {
  // Implementation depends on your authentication system
  return localStorage.getItem('auth_token') || '';
}`;

    const outputPath = path.join(this.outputDir, 'api', `${domain}API.ts`);
    
    // Ensure api directory exists
    const apiDir = path.join(this.outputDir, 'api');
    if (!fs.existsSync(apiDir)) {
      fs.mkdirSync(apiDir, { recursive: true });
    }
    
    fs.writeFileSync(outputPath, endpointCode);
    
    console.log(`üåê Generated API endpoints: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate comprehensive test suite
   */
  generateTestSuite(config) {
    const { featureName, testTypes = [], coverage = {} } = config;
    
    const testFiles = [];

    // Generate unit tests
    if (testTypes.includes('unit')) {
      testFiles.push(this.generateUnitTests(featureName, coverage.unit));
    }

    // Generate integration tests
    if (testTypes.includes('integration')) {
      testFiles.push(this.generateIntegrationTests(featureName, coverage.integration));
    }

    // Generate E2E tests
    if (testTypes.includes('e2e')) {
      testFiles.push(this.generateE2ETests(featureName, coverage.e2e));
    }

    console.log(`üß™ Generated test suite for ${featureName}: ${testFiles.length} test files`);
    return testFiles;
  }

  /**
   * Generate unit tests using Jest and React Testing Library
   */
  generateUnitTests(featureName, coverage = {}) {
    const testCode = `/**
 * ${featureName} Unit Tests
 * Generated by Agent Factory
 */

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { jest } from '@jest/globals';
import ${this.toPascalCase(featureName)} from '../components/${this.toPascalCase(featureName)}';

// Mock API calls
jest.mock('../api/${featureName}API', () => ({
  ${this.toPascalCase(featureName)}APIClient: {
    getData: jest.fn(),
    createRecord: jest.fn(),
    updateRecord: jest.fn(),
    deleteRecord: jest.fn()
  }
}));

describe('${this.toPascalCase(featureName)} Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(<${this.toPascalCase(featureName)} />);
    expect(screen.getByText('${this.toPascalCase(featureName)}')).toBeInTheDocument();
  });

  it('displays loading state', () => {
    render(<${this.toPascalCase(featureName)} />);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('handles API errors gracefully', async () => {
    const mockError = new Error('API Error');
    // Mock API to throw error
    
    render(<${this.toPascalCase(featureName)} />);
    
    await waitFor(() => {
      expect(screen.getByText(/Error:/)).toBeInTheDocument();
    });
  });

  it('handles user interactions', async () => {
    render(<${this.toPascalCase(featureName)} />);
    
    const actionButton = screen.getByText('Action');
    fireEvent.click(actionButton);
    
    // Add assertions for expected behavior
  });

  // Add more specific tests based on component functionality
});

describe('${featureName} API Client', () => {
  // Add API client tests
});

describe('${featureName} Utility Functions', () => {
  // Add utility function tests
});`;

    const outputPath = path.join(this.outputDir, 'tests', `${featureName}.test.tsx`);
    
    // Ensure tests directory exists
    const testsDir = path.join(this.outputDir, 'tests');
    if (!fs.existsSync(testsDir)) {
      fs.mkdirSync(testsDir, { recursive: true });
    }
    
    fs.writeFileSync(outputPath, testCode);
    
    console.log(`üî¨ Generated unit tests: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate Playwright E2E tests
   */
  generateE2ETests(featureName, coverage = {}) {
    const testCode = `/**
 * ${featureName} End-to-End Tests
 * Generated by Agent Factory using Playwright
 */

import { test, expect, Page } from '@playwright/test';

test.describe('${this.toPascalCase(featureName)} Feature', () => {
  let page: Page;

  test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();
    
    // Navigate to the feature page
    await page.goto('/dashboard/${featureName}');
    
    // Wait for page to load
    await page.waitForLoadState('networkidle');
  });

  test('should display ${featureName} component', async () => {
    // Check if main component is visible
    await expect(page.locator('[data-testid="${featureName}-container"]')).toBeVisible();
    
    // Verify page title
    await expect(page).toHaveTitle(new RegExp('${this.toPascalCase(featureName)}'));
  });

  test('should handle user workflow', async () => {
    // Test complete user workflow
    await page.click('[data-testid="action-button"]');
    
    // Wait for response
    await page.waitForResponse(response => 
      response.url().includes('api/${featureName}') && response.status() === 200
    );
    
    // Verify results
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
  });

  test('should handle error states', async () => {
    // Mock API error
    await page.route('**/api/${featureName}/**', route => {
      route.fulfill({
        status: 500,
        contentType: 'application/json',
        body: JSON.stringify({ error: 'Server error' })
      });
    });

    // Trigger action that calls API
    await page.click('[data-testid="action-button"]');
    
    // Verify error handling
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
  });

  test('should be accessible', async () => {
    // Run accessibility checks
    const accessibilityScan = await page.accessibility.snapshot();
    
    // Verify essential accessibility features
    await expect(page.locator('h1, h2, h3')).toHaveCount(1); // Should have heading
    await expect(page.locator('[role="main"]')).toBeVisible(); // Main content area
    
    // Check for form labels if forms exist
    const forms = await page.locator('form').count();
    if (forms > 0) {
      await expect(page.locator('label')).toHaveCount(forms);
    }
  });

  test('should work on mobile devices', async () => {
    // Set mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    
    // Verify mobile responsiveness
    await expect(page.locator('[data-testid="${featureName}-container"]')).toBeVisible();
    
    // Test mobile-specific interactions
    await page.click('[data-testid="mobile-menu"]');
    await expect(page.locator('[data-testid="mobile-nav"]')).toBeVisible();
  });
});`;

    const outputPath = path.join(this.outputDir, 'tests', `${featureName}.e2e.spec.ts`);
    fs.writeFileSync(outputPath, testCode);
    
    console.log(`üé≠ Generated E2E tests: ${outputPath}`);
    return outputPath;
  }

  /**
   * Utility methods
   */
  toPascalCase(str) {
    return str.replace(/(?:^|[_-])(\w)/g, (_, char) => char.toUpperCase());
  }

  mapDatabaseTypeToTS(dbType) {
    const typeMap = {
      'VARCHAR': 'string',
      'TEXT': 'string',
      'INTEGER': 'number',
      'BIGINT': 'number',
      'DECIMAL': 'number',
      'BOOLEAN': 'boolean',
      'TIMESTAMP': 'string',
      'DATE': 'string',
      'JSONB': 'Record<string, any>',
      'UUID': 'string'
    };
    
    return typeMap[dbType.toUpperCase()] || 'any';
  }

  generateIntegrationTests(featureName, coverage) {
    // Integration test implementation
    const testCode = `/**
 * ${featureName} Integration Tests
 * Generated by Agent Factory
 */

import { APIResponse } from '../types/API';
import { ${this.toPascalCase(featureName)}APIClient } from '../api/${featureName}API';

describe('${featureName} Integration Tests', () => {
  // Add integration tests here
  
  it('should integrate with backend API', async () => {
    // Test API integration
    const result = await ${this.toPascalCase(featureName)}APIClient.getData();
    expect(result.success).toBe(true);
  });
});`;

    const outputPath = path.join(this.outputDir, 'tests', `${featureName}.integration.test.ts`);
    fs.writeFileSync(outputPath, testCode);
    
    console.log(`üîó Generated integration tests: ${outputPath}`);
    return outputPath;
  }
}

module.exports = AgentFactoryAgent;