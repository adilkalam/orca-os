#!/usr/bin/env node

/**
 * Security Agent - Security Vulnerability Scanner
 * Analyzes code for security issues, OWASP compliance, and AWS best practices
 */

const PathScanningHelper = require('../../equilateral-core/PathScanningHelper');

class SecurityAgent {
  constructor() {
    this.findings = {
      critical: [],
      high: [],
      medium: [],
      low: [],
      info: []
    };
    
    this.scanPatterns = {
      sqlInjection: {
        patterns: [
          /query\s*\(\s*['"`].*\+.*\$\{/g,
          /query\s*\(\s*`[^`]*\$\{(?![\d]+\})/g,
          /executeQuery\([^,)]*\+[^,)]*\)/g
        ],
        severity: 'critical',
        message: 'Potential SQL injection vulnerability'
      },
      
      hardcodedSecrets: {
        patterns: [
          /password\s*[:=]\s*['"`][^'"`]{8,}/gi,
          /api[_-]?key\s*[:=]\s*['"`][A-Za-z0-9]{20,}/gi,
          /secret\s*[:=]\s*['"`][^'"`]{10,}/gi,
          /private[_-]?key\s*[:=]\s*['"`]/gi
        ],
        severity: 'critical',
        message: 'Hardcoded credentials or secrets found'
      },
      
      xss: {
        patterns: [
          /innerHTML\s*=\s*[^'"`]/g,
          /dangerouslySetInnerHTML/g,
          /document\.write\s*\(/g,
          /eval\s*\(/g
        ],
        severity: 'high',
        message: 'Potential XSS vulnerability'
      },
      
      insecureRandom: {
        patterns: [
          /Math\.random\(\)/g
        ],
        severity: 'medium',
        message: 'Math.random() is not cryptographically secure'
      },
      
      missingAuth: {
        patterns: [
          /handler(?!.*requireAuth)(?!.*authorization)(?!.*auth)/gi
        ],
        severity: 'high',
        message: 'Handler may be missing authentication'
      },
      
      noRateLimit: {
        patterns: [
          /POST|PUT|DELETE(?!.*rateLimit)(?!.*throttle)/g
        ],
        severity: 'medium',
        message: 'Endpoint missing rate limiting'
      },
      
      httpInsteadOfHttps: {
        patterns: [
          /http:\/\/(?!localhost|127\.0\.0\.1)/g
        ],
        severity: 'high',
        message: 'Using HTTP instead of HTTPS'
      },
      
      weakCrypto: {
        patterns: [
          /createHash\(['"`]md5['"`]\)/g,
          /createHash\(['"`]sha1['"`]\)/g
        ],
        severity: 'high',
        message: 'Using weak cryptographic algorithm'
      },
      
      commandInjection: {
        patterns: [
          /exec\s*\(/g,
          /spawn\s*\([^'"`]*\$\{/g,
          /child_process/g
        ],
        severity: 'critical',
        message: 'Potential command injection vulnerability'
      },
      
      pathTraversal: {
        patterns: [
          /readFile[^(]*\([^'"`]*\+/g,
          /path\.join\([^)]*\.\./g
        ],
        severity: 'high',
        message: 'Potential path traversal vulnerability'
      },
      
      insecureCORS: {
        patterns: [
          /Access-Control-Allow-Origin['":\s]*\*/g
        ],
        severity: 'medium',
        message: 'CORS allows all origins'
      },
      
      noInputValidation: {
        patterns: [
          /requestBody(?!.*validate)(?!.*validation)/g
        ],
        severity: 'high',
        message: 'Request body used without validation'
      },
      
      exposedErrorDetails: {
        patterns: [
          /stack(?:\s*:|trace)/g,
          /error\.stack/g
        ],
        severity: 'low',
        message: 'Stack traces may be exposed to users'
      },
      
      missingCSRF: {
        patterns: [
          /form(?!.*csrf)(?!.*token)/gi
        ],
        severity: 'medium',
        message: 'Form may be missing CSRF protection'
      },
      
      logInjection: {
        patterns: [
          /console\.log\([^)]*\$\{/g,
          /logger\.[^(]*\([^)]*\$\{/g
        ],
        severity: 'low',
        message: 'Potential log injection'
      }
    };

    // Initialize path scanner for vulnerability scanning
    this.pathScanner = new PathScanningHelper({
      verbose: false,
      extensions: {
        all: ['.js', '.ts', '.py', '.java', '.go', '.rs']
      },
      maxDepth: 10
    });
  }

  async scanFile(filePath, content) {
    const relativePath = filePath.replace(process.cwd() + '/', '');
    
    // Skip test files and node_modules
    if (relativePath.includes('node_modules') || 
        relativePath.includes('test') || 
        relativePath.includes('.spec.')) {
      return;
    }
    
    // Scan for each security pattern
    for (const [checkName, check] of Object.entries(this.scanPatterns)) {
      for (const pattern of check.patterns) {
        const matches = content.matchAll(pattern);
        
        for (const match of matches) {
          const lineNumber = this.getLineNumber(content, match.index);
          
          this.findings[check.severity].push({
            file: relativePath,
            line: lineNumber,
            type: checkName,
            message: check.message,
            code: match[0].substring(0, 100),
            recommendation: this.getRecommendation(checkName)
          });
        }
      }
    }
    
    // Additional checks
    this.checkAwsSecurityBestPractices(relativePath, content);
    this.checkCoppaCompliance(relativePath, content);
    this.checkDatabaseSecurity(relativePath, content);
    this.checkAuthenticationSecurity(relativePath, content);
  }

  checkAwsSecurityBestPractices(file, content) {
    // Check for AWS credentials
    if (content.match(/AKIA[0-9A-Z]{16}/)) {
      this.findings.critical.push({
        file,
        type: 'aws_credentials',
        message: 'AWS access key found in code',
        recommendation: 'Use IAM roles or AWS Secrets Manager'
      });
    }
    
    // Check for unencrypted S3 operations
    if (content.includes('s3.putObject') && !content.includes('ServerSideEncryption')) {
      this.findings.medium.push({
        file,
        type: 'unencrypted_s3',
        message: 'S3 upload without encryption',
        recommendation: 'Add ServerSideEncryption: "AES256" to S3 operations'
      });
    }
    
    // Check for public S3 bucket
    if (content.includes('ACL: "public-read"')) {
      this.findings.high.push({
        file,
        type: 'public_s3',
        message: 'S3 bucket configured for public access',
        recommendation: 'Use pre-signed URLs instead of public buckets'
      });
    }
    
    // Check Lambda environment variables
    if (content.includes('process.env') && content.includes('password')) {
      this.findings.medium.push({
        file,
        type: 'env_password',
        message: 'Password stored in environment variable',
        recommendation: 'Use AWS Secrets Manager or Parameter Store'
      });
    }
  }

  checkCoppaCompliance(file, content) {
    // Check for child data handling
    if (content.includes('child') || content.includes('age')) {
      // Check for age verification
      if (!content.includes('age') || !content.includes('13')) {
        this.findings.high.push({
          file,
          type: 'coppa_age_verification',
          message: 'Child data handling without age verification',
          recommendation: 'Implement age verification for users under 13'
        });
      }
      
      // Check for parental consent
      if (content.includes('child') && !content.includes('parentalConsent')) {
        this.findings.high.push({
          file,
          type: 'coppa_consent',
          message: 'Child account creation without parental consent check',
          recommendation: 'Require parental consent for children under 13'
        });
      }
    }
  }

  checkDatabaseSecurity(file, content) {
    // Check for parameterized queries
    if (content.includes('executeQuery')) {
      const queryMatches = content.matchAll(/executeQuery\s*\([^)]+\)/g);
      
      for (const match of queryMatches) {
        const queryCall = match[0];
        
        // Check if using template literals with variables
        if (queryCall.includes('${') && !queryCall.includes('$1')) {
          this.findings.critical.push({
            file,
            line: this.getLineNumber(content, match.index),
            type: 'sql_injection_risk',
            message: 'SQL query using template literals instead of parameters',
            code: queryCall.substring(0, 100),
            recommendation: 'Use parameterized queries: executeQuery(query, [param1, param2])'
          });
        }
      }
    }
    
    // Check for transaction handling
    if (content.includes('BEGIN') && !content.includes('ROLLBACK')) {
      this.findings.medium.push({
        file,
        type: 'missing_rollback',
        message: 'Transaction without proper rollback handling',
        recommendation: 'Add try/catch with ROLLBACK on error'
      });
    }
  }

  checkAuthenticationSecurity(file, content) {
    // Check for JWT secret
    if (content.includes('jwt.sign') && content.includes('"secret"')) {
      this.findings.critical.push({
        file,
        type: 'weak_jwt_secret',
        message: 'Weak or hardcoded JWT secret',
        recommendation: 'Use strong secret from environment/secrets manager'
      });
    }
    
    // Check password requirements
    if (content.includes('password') && !content.includes('bcrypt') && !content.includes('argon2')) {
      this.findings.high.push({
        file,
        type: 'plain_password',
        message: 'Password handling without proper hashing',
        recommendation: 'Use bcrypt or argon2 for password hashing'
      });
    }
    
    // Check session management
    if (content.includes('session') && !content.includes('secure')) {
      this.findings.medium.push({
        file,
        type: 'insecure_session',
        message: 'Session cookie without secure flag',
        recommendation: 'Set secure: true for session cookies'
      });
    }
  }

  getLineNumber(content, index) {
    return content.substring(0, index).split('\n').length;
  }

  getRecommendation(checkType) {
    const recommendations = {
      sqlInjection: 'Use parameterized queries: executeQuery(sql, [param1, param2])',
      hardcodedSecrets: 'Store secrets in AWS Secrets Manager or Parameter Store',
      xss: 'Use textContent or sanitize HTML content before rendering',
      insecureRandom: 'Use crypto.randomBytes() for security-sensitive operations',
      missingAuth: 'Add requireAuth middleware to protected endpoints',
      noRateLimit: 'Implement rate limiting with express-rate-limit or API Gateway throttling',
      httpInsteadOfHttps: 'Always use HTTPS for external connections',
      weakCrypto: 'Use SHA-256 or stronger algorithms',
      commandInjection: 'Avoid exec/spawn, use specific functions instead',
      pathTraversal: 'Validate and sanitize file paths',
      insecureCORS: 'Specify allowed origins explicitly',
      noInputValidation: 'Validate all user inputs with a schema validator',
      exposedErrorDetails: 'Only log stack traces in development',
      missingCSRF: 'Implement CSRF tokens for state-changing operations',
      logInjection: 'Sanitize user input before logging'
    };
    
    return recommendations[checkType] || 'Review and fix security issue';
  }

  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        critical: this.findings.critical.length,
        high: this.findings.high.length,
        medium: this.findings.medium.length,
        low: this.findings.low.length,
        info: this.findings.info.length,
        total: Object.values(this.findings).reduce((sum, arr) => sum + arr.length, 0)
      },
      findings: this.findings,
      securityScore: this.calculateSecurityScore(),
      recommendations: this.generateTopRecommendations(),
      compliance: {
        owasp: this.checkOwaspCompliance(),
        coppa: this.checkCoppaStatus(),
        aws: this.checkAwsCompliance()
      }
    };
    
    return report;
  }

  calculateSecurityScore() {
    const weights = {
      critical: -30,
      high: -15,
      medium: -5,
      low: -2,
      info: 0
    };
    
    let score = 100;
    
    for (const [severity, issues] of Object.entries(this.findings)) {
      score += weights[severity] * issues.length;
    }
    
    return Math.max(0, score);
  }

  generateTopRecommendations() {
    const recommendations = [];
    
    if (this.findings.critical.length > 0) {
      recommendations.push({
        priority: 1,
        action: 'Fix critical security vulnerabilities immediately',
        details: `Found ${this.findings.critical.length} critical issues that could lead to data breach`
      });
    }
    
    if (this.findings.high.filter(f => f.type === 'missingAuth').length > 0) {
      recommendations.push({
        priority: 2,
        action: 'Implement authentication on all endpoints',
        details: 'Multiple handlers missing authentication checks'
      });
    }
    
    if (this.findings.medium.filter(f => f.type === 'noRateLimit').length > 0) {
      recommendations.push({
        priority: 3,
        action: 'Add rate limiting to prevent abuse',
        details: 'Implement API Gateway throttling or Lambda rate limiting'
      });
    }
    
    return recommendations;
  }

  checkOwaspCompliance() {
    return {
      injection: this.findings.critical.filter(f => f.type === 'sqlInjection').length === 0,
      brokenAuth: this.findings.high.filter(f => f.type === 'missingAuth').length === 0,
      xss: this.findings.high.filter(f => f.type === 'xss').length === 0,
      insecureDesign: this.findings.medium.length < 5,
      securityMisconfig: this.findings.high.filter(f => f.type === 'insecureCORS').length === 0,
      score: this.findings.critical.length === 0 ? 'PASS' : 'FAIL'
    };
  }

  checkCoppaStatus() {
    const coppaIssues = [...this.findings.high, ...this.findings.critical]
      .filter(f => f.type && f.type.includes('coppa'));
    
    return {
      compliant: coppaIssues.length === 0,
      issues: coppaIssues.length,
      details: coppaIssues.map(i => i.message)
    };
  }

  checkAwsCompliance() {
    const awsIssues = [...this.findings.critical, ...this.findings.high]
      .filter(f => f.type && (f.type.includes('aws') || f.type.includes('s3')));
    
    return {
      bestPractices: awsIssues.length === 0,
      issues: awsIssues.length,
      recommendations: awsIssues.map(i => i.recommendation)
    };
  }
}

// CLI execution
async function runSecurityScan() {
  const fs = require('fs').promises;
  const path = require('path');
  const agent = new SecurityAgent();
  
  console.log('ðŸ”’ Security Agent - Scanning for vulnerabilities...\n');
  
  // Scan source files - use common patterns with fallbacks
  const scanDirs = [
    'backend/src/handlers',
    'backend/src/shared',
    'src/backend/handlers',
    'src/handlers',
    'handlers',
    'frontend/src/components',
    'frontend/src/services',
    'src/frontend/components',
    'src/frontend/services',
    'src/components',
    'src/services',
    'components',
    'services'
  ];
  
  for (const dir of scanDirs) {
    try {
      const fullPath = path.join(process.cwd(), dir);
      await scanDirectory(fullPath, agent);
    } catch (error) {
      console.log(`Skipping ${dir}: ${error.message}`);
    }
  }
  
  async function scanDirectory(dir, agent) {
    const files = await fs.readdir(dir, { withFileTypes: true });
    
    for (const file of files) {
      const fullPath = path.join(dir, file.name);
      
      if (file.isDirectory()) {
        await scanDirectory(fullPath, agent);
      } else if (file.name.endsWith('.js') || file.name.endsWith('.ts')) {
        const content = await fs.readFile(fullPath, 'utf-8');
        await agent.scanFile(fullPath, content);
      }
    }
  }
  
  // Generate report
  const report = agent.generateReport();
  
  // Display results
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('                    SECURITY SCAN RESULTS                   ');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  console.log(`Security Score: ${report.securityScore}/100`);
  console.log('');
  console.log('Issue Summary:');
  console.log(`  ðŸ”´ Critical: ${report.summary.critical}`);
  console.log(`  ðŸŸ  High: ${report.summary.high}`);
  console.log(`  ðŸŸ¡ Medium: ${report.summary.medium}`);
  console.log(`  ðŸ”µ Low: ${report.summary.low}`);
  console.log(`  â„¹ï¸  Info: ${report.summary.info}`);
  console.log('');
  
  // Show critical issues
  if (report.findings.critical.length > 0) {
    console.log('ðŸ”´ CRITICAL ISSUES (Fix Immediately):');
    report.findings.critical.forEach((issue, i) => {
      console.log(`\n${i + 1}. ${issue.message}`);
      console.log(`   File: ${issue.file}${issue.line ? ':' + issue.line : ''}`);
      console.log(`   Fix: ${issue.recommendation}`);
    });
    console.log('');
  }
  
  // Show high priority issues
  if (report.findings.high.length > 0) {
    console.log('ðŸŸ  HIGH PRIORITY ISSUES:');
    report.findings.high.slice(0, 5).forEach((issue, i) => {
      console.log(`\n${i + 1}. ${issue.message}`);
      console.log(`   File: ${issue.file}${issue.line ? ':' + issue.line : ''}`);
      console.log(`   Fix: ${issue.recommendation}`);
    });
    console.log('');
  }
  
  // Compliance status
  console.log('ðŸ“‹ Compliance Status:');
  console.log(`  OWASP Top 10: ${report.compliance.owasp.score}`);
  console.log(`  COPPA: ${report.compliance.coppa.compliant ? 'âœ… Compliant' : 'âŒ Non-compliant'}`);
  console.log(`  AWS Best Practices: ${report.compliance.aws.bestPractices ? 'âœ… Following' : 'âš ï¸ Issues found'}`);
  console.log('');
  
  // Top recommendations
  console.log('ðŸŽ¯ Top Security Recommendations:');
  report.recommendations.forEach(rec => {
    console.log(`\n${rec.priority}. ${rec.action}`);
    console.log(`   ${rec.details}`);
  });
  
  // Save detailed report
  await fs.writeFile(
    'security-scan-results.json',
    JSON.stringify(report, null, 2)
  );
  
  console.log('\nðŸ’¾ Detailed report saved to: security-scan-results.json');
  
  return report;
}

// Run if called directly
if (require.main === module) {
  runSecurityScan().catch(console.error);
}

module.exports = SecurityAgent;